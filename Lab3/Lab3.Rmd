---
title: "Lab3"
author: "Damian Ke & Kyriakos Papadopoulos"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Question 1: Stable distribution

## 1.1
```{r, warning=FALSE}
library(poweRlaw)
library(ggplot2)
library(gridExtra)


target_function <- function(x, c){
  res = c * sqrt(2 * pi) ^ (-1) * exp((-c^2) / (2*x)) * x ^ (-3/2)
}

majority_function <- function(x, a, t_min){
  res <- c()
  
  for(i in 1:length(x)){
    if(x[i] <= t_min){
      res[i] = ((a - 1) / t_min) * (t_min/t_min) ^ (-a)
    }
    else{
      res[i] <- ((a - 1) / t_min) * (x[i]/t_min) ^ (-a)
    }
  }
  
  return(res)
}

t_min=1.5
c=1.5
alpha=1.5

ggplot() +
  xlim(0.1, 10) +
  geom_function(fun = target_function, args = list(c = c), colour = "red") +
  geom_function(fun = majority_function, colour = "black", args = list(a=alpha,t_min=t_min))


```


**Q.1:** Plot f(x) and fp(x) together. Can the power-law distribution be used just by itself or is
there a problem at any place of the support Explain what the problem is and how can it
be taken care of. Provide values of the power{law distribution's parameters that can be
used in the acceptance-rejection algorithm. Derive and implement a majorizing density.

**A: ** Missing values at fp(x) between to t_min, which cant generate values for these
values. Solution for this issue is to find another distribution or line that
envelopts the target function.

For example:
t_min=1.5
c=1.5
alpha=1.5
This makes the supported majorizing density envelop the target density.

!!! (NOT SURE)Later on, it will be multiplied by a majorizing constant to envelop the target density.
but when the values goes towards infinity, the majorizing density is higher than target density.
The only value that needs to be found is the between 0 to Tmin to have a fully completed majorizing density.

The majorizing density lack support from (0,Tmin)
To get values for corresponding range, a line will be created from the majorizing density function.


## 1.2

```{r}

x <- seq(0.001, 10, 0.001)

prob <- sum(x <= t_min) / (sum(x))

# For x bigger than t_min
maj_c1 <- max(target_function(x[x>t_min],c) / majority_function(x[x>t_min], alpha, t_min))

# For x smaller than t_min

maj_c2 <- max(target_function(x[x<=t_min],c) / majority_function(x[x<=t_min], alpha, t_min))

n = 5000

accept_reject <- function(n,c){
  values <- c()
  rejects <- 0
  for(i in 1:n){
    x <- NA
    
    while(is.na(x)){
      prob2 <- sample(0:1, 1, prob = c(prob, 1-prob))
      # For 0 is x <= tmin
      # For 1 is x > tmin
      u <- runif(1)
      
      
      if(prob2 == 0){
        y <- runif(1, 0, t_min)
        
        if(u <= target_function(y, c) / (maj_c2 * majority_function(y, alpha, t_min))){
          x <- y
          values <- append(values, x)
        }else{
          rejects <- rejects + 1
        }
      }
      else{
        y <- rplcon(1, xmin = t_min, alpha = alpha)
        
        if(u <= target_function(y, c) / (maj_c1 * majority_function(y, alpha, t_min))){
          x <- y
          values <- append(values, x)
        }else{
          rejects <- rejects + 1
        }
      }
      
    }
    
  }
  return(c(values,rejects))
}

```

**Q.2:** Implement an acceptance{rejection algorithm for sampling from the one{sided strictly
stable distribution of order 1=2 with the proposal distribution built around the power{
law distribution. To sample from a power{law distribution you can use the function
poweRlaw::rplcon().

## 1.3
```{r}
c_list = c(1,2,3,4,5,6)
results = data.frame(matrix(NA,ncol=length(c_list),nrow=n))
summarized_results = data.frame(matrix(NA,ncol=length(c_list),nrow=3))
plots = c()
df = data.frame()
for (i in 1:length(c_list)) {
  var <- c_list[i]
  answer = accept_reject(n,var)
  rejects = answer[n+1]
  #values = answer[1:n]
  results[i] = answer[1:n]
  summarized_results[1,i] = format(mean(answer[1:n]), digits=10)
  summarized_results[2,i] = format(var(answer[1:n]), digits=10)
  summarized_results[3,i] = format(rejects/n, digits=10)
  df = data.frame(results)
  #plots[i] <- hist(results[i][results[i] < 200], col="green", breaks=70, xlab="", ylab="sample density", freq=FALSE, main="")
}
colnames(results) = c("c1","c2","c3","c4","c5","c6")
colnames(df) = c("c1","c2","c3","c4","c5","c6")
colnames(summarized_results) = c("c1","c2","c3","c4","c5","c6")
rownames(summarized_results) = c("Mean","Variance","Rejection Rate")


create_plot <- function(i){
  title = paste("c = ", i, sep = "")
  
  hist(results[i][results[i] < 200], col="green", breaks=70, xlab="", ylab="sample density", freq=FALSE, main=title)
}

# Code to show all the graphs
par(mfrow=c(3,2))
plots = sapply(1:6, create_plot)

summarized_results
```

**Q.3: ** Generate a large sample using your implemented sampler, for different choices of c. Present
the sample graphically. What is the mean and variance and how do they depend on c?
Study the rejection rate.

**A :** For the corresponding values of c, the mean and variance increases as c increases.
The rejection rate, seems to decrease at around c=2, and then increase as c increases.
This can be due to results found in the figures corresponding to different c values.
For higher number of C, the target distribution moves towards right, it can be seen that both mean and variance
increases which means that more sample values from the acceptance-rejection algorithm will be outside
of the target function.